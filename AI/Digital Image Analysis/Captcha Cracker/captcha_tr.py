import sys
import numpy as np
from typing import List, Tuple, TextIO
from templates_snippet import TEMPLATES  # <- generated by make_templates.py


def read_bgr_txt(fp: TextIO) -> np.ndarray:
    """
    Read an image stored in plain-text BGR format.

    Args:
        fp: Open file-like object containing:
            - First line: "R C" (rows and columns).
            - Following lines: each pixel as "B,G,R" separated by spaces.

    Returns:
        NumPy array of shape (R, C, 3) with dtype=uint8.
    """
    R, C = map(int, fp.readline().split())
    img = np.zeros((R, C, 3), dtype=np.uint8)
    for r in range(R):
        row = fp.readline().split()
        for c, pix in enumerate(row):
            b, g, r_ = map(int, pix.split(','))
            img[r, c] = [b, g, r_]
    return img


def to_binary(img: np.ndarray) -> np.ndarray:
    """
    Convert a color image into a binary (black/white) mask.

    Args:
        img: Input RGB image as a NumPy array of shape (R, C, 3).

    Returns:
        Binary 2D array (R, C) with values {0,1}, where 1 marks "ink".
    """
    # Convert to grayscale using standard luminance weights
    gray = (0.114 * img[..., 0] + 0.587 * img[..., 1] + 0.299 * img[..., 2]).astype(np.uint8)
    # Threshold is either 128 or the mean intensity, whichever is higher
    thr = max(128, int(gray.mean()))
    return (gray < thr).astype(np.uint8)


def smooth_1d(x: np.ndarray, k: int = 5) -> np.ndarray:
    """
    Smooth a 1D signal using a uniform kernel.

    Args:
        x: 1D array.
        k: Kernel size.

    Returns:
        Smoothed 1D array.
    """
    if k <= 1:
        return x
    ker = np.ones(k) / k
    return np.convolve(x, ker, mode='same')


def find_runs(mask: np.ndarray) -> List[Tuple[int, int]]:
    """
    Find continuous runs of 1's in a binary mask.

    Args:
        mask: 1D binary array.

    Returns:
        List of (start, end) indices for each run.
    """
    runs, on, s = [], False, 0
    for i, v in enumerate(mask):
        if v and not on:
            on, s = True, i
        if not v and on:
            on = False
            runs.append((s, i - 1))
    if on:
        runs.append((s, len(mask) - 1))
    return runs


def merge_close_runs(runs: List[Tuple[int, int]], max_gap: int = 2) -> List[Tuple[int, int]]:
    """
    Merge runs that are separated by small gaps.

    Args:
        runs: List of (start, end) index pairs.
        max_gap: Maximum allowed gap between runs to merge them.

    Returns:
        List of merged runs.
    """
    if not runs:
        return []
    out = [runs[0]]
    for a, b in runs[1:]:
        A, B = out[-1]
        if a - B - 1 <= max_gap:
            out[-1] = (A, b)
        else:
            out.append((a, b))
    return out


def guess_char_bands(bw: np.ndarray) -> List[Tuple[int, int]]:
    """
    Segment a binary captcha image into 5 character bands.

    Args:
        bw: Binary image (R, C).

    Returns:
        List of 5 (left, right) index pairs marking character bands.
    """
    col_sum = bw.sum(axis=0)
    s = smooth_1d(col_sum, 5)
    thr = max(1, int(0.20 * s.max()))
    mask = (s >= thr).astype(np.uint8)
    runs = merge_close_runs(find_runs(mask), 2)

    # If segmentation failed, fall back to equal slicing
    if len(runs) != 5:
        C = bw.shape[1]
        step = C // 5
        runs = [
            (max(0, i * step - 1), C - 1 if i == 4 else min(C - 1, (i + 1) * step + 1))
            for i in range(5)
        ]

    # Tighten band boundaries by trimming empty columns
    tight = []
    for L, R in runs:
        seg = col_sum[L:R + 1]
        if seg.sum() == 0:
            tight.append((L, R))
            continue
        l = 0
        while l < len(seg) and seg[l] == 0:
            l += 1
        r = 0
        while r < len(seg) and seg[-1 - r] == 0:
            r += 1
        tight.append((L + l, R - r))
    return tight


def tight_crop(bw_band: np.ndarray) -> np.ndarray:
    """
    Crop vertical whitespace from a band.

    Args:
        bw_band: Binary image segment.

    Returns:
        Cropped binary image with minimal top/bottom margin.
    """
    rows = bw_band.sum(axis=1)
    if rows.sum() == 0:
        return bw_band
    top = np.argmax(rows > 0)
    bottom = len(rows) - 1 - np.argmax(rows[::-1] > 0)
    return bw_band[top:bottom + 1, :]


def resize_nn(a: np.ndarray, H: int = 24, W: int = 16) -> np.ndarray:
    """
    Resize a 2D binary image to (H, W) using nearest-neighbor sampling.

    Args:
        a: Input binary image.
        H: Target height.
        W: Target width.

    Returns:
        Resized binary image (H, W).
    """
    h, w = a.shape
    r_idx = (np.linspace(0, h - 1, H)).astype(int)
    c_idx = (np.linspace(0, w - 1, W)).astype(int)
    return a[r_idx][:, c_idx].astype(np.uint8)


def mse(a: np.ndarray, b: np.ndarray) -> float:
    """
    Compute mean squared error (MSE) between two patches.

    Args:
        a: Binary patch (H, W).
        b: Binary patch (H, W).

    Returns:
        Scalar mean squared error.
    """
    d = a.astype(np.int16) - b.astype(np.int16)
    return float((d * d).mean())


def predict_char(patch: np.ndarray) -> str:
    """
    Predict a single character by template matching.

    Args:
        patch: Binary patch (24, 16).

    Returns:
        Predicted character as string.
    """
    best_ch, best_s = '?', 1e9
    for ch, exs in TEMPLATES.items():
        for ex in exs:
            s = mse(patch, ex)
            if s < best_s:
                best_s, best_ch = s, ch
    return best_ch


if __name__ == "__main__":
    # Read captcha image from stdin
    img = read_bgr_txt(sys.stdin)
    # Convert to binary ink/background mask
    bw = to_binary(img)
    # Split into 5 character bands
    bands = guess_char_bands(bw)

    out: List[str] = []
    for L, R in bands:
        band = bw[:, L:R + 1]
        band = tight_crop(band)
        patch = resize_nn(band, 24, 16)
        out.append(predict_char(patch))

    
    print("".join(out))
